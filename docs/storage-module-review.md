# 아키텍처 분석: 스토리지 모듈 물리적 분리의 이점 및 가치

## 1. 개요

본 문서는 현재 프로젝트의 멀티 모듈 구조에서 영속성 계층(Persistence Layer, 이하 `storage` 모듈)을 `core-api` 모듈과 물리적으로 분리하여 운영할 때 얻을 수 있는 아키텍처적 이점과 활용 사례를 기술한다.

## 2. 상세 분석

### 2.1. 다중 애플리케이션 환경에서의 재사용성 (Reusability)

`storage` 모듈이 독립적으로 존재할 때, 데이터베이스 스키마와 접근 로직을 여러 배포 단위(Deployable Unit)에서 공유하기 용이하다.

* **배치(Batch) / 어드민(Admin) 서버:** 배치 애플리케이션은 대용량 데이터 처리를 위해 DB 접근이 필요하지만, API 서버의 무거운 비즈니스 로직이나 웹 프레임워크(Security, MVC 등) 의존성은 불필요하다. 스토리지 모듈 분리 시, 배치 서버는 `storage` 모듈만 의존함으로써 경량화된 상태로 데이터 계층을 재사용할 수 있다.
* **결합도 감소:** API 서비스 로직의 변경이 배치나 어드민 서버의 실행에 영향을 주지 않는 느슨한 결합(Loose Coupling) 구조를 유지할 수 있다.

### 2.2. 도메인 모델의 순수성 강제 (Enforced Purity)

물리적인 모듈 분리는 의존성 방향을 강제하여 엔티티(Entity) 클래스의 오염을 방지한다.

* **의존성 방향 제어:** `api` 모듈은 `storage` 모듈을 참조하지만, `storage` 모듈은 `api` 모듈을 참조할 수 없다(단방향 의존성).
* **프레젠테이션 계층 침투 방지:** Jackson(`@JsonIgnore`), Swagger(`@Schema`), Validation(`@NotNull`) 등 웹 계층이나 UI 처리를 위한 어노테이션이 엔티티 클래스에 추가되는 것을 물리적으로 차단한다. 이는 엔티티를 순수한 데이터 객체로 유지하게 한다.

### 2.3. 빌드 성능 최적화 (Build Performance)

Gradle 등 빌드 도구의 증분 빌드(Incremental Build) 기능을 극대화할 수 있다.

* **변경 범위 격리:** 비즈니스 로직이나 컨트롤러가 포함된 상위 모듈(`api`)이 수정되더라도, 하위 모듈인 `storage` 모듈에는 변경이 없으므로 컴파일 및 테스트 수행이 생략된다(Up-to-date).
* **CI/CD 속도 향상:** 엔티티나 스키마 변경보다 비즈니스 로직 변경 빈도가 높은 일반적인 개발 환경에서 전체 빌드 시간을 단축하는 효과가 있다.

### 2.4. 기술 스택의 유연성 (Tech Stack Flexibility)

영속성 계층의 구현 기술을 비즈니스 로직과 분리하여 관리할 수 있다.

* **기술 교체 및 혼용:** JPA 기반의 구현체를 JDBC Template, MyBatis, JOOQ 등으로 전환하거나 혼용해야 할 때, 변경 범위가 `storage` 모듈 내부로 한정된다.
* **영향도 최소화:** 비즈니스 계층은 인터페이스에 의존하고 구현체는 모듈 단위로 교체되므로, 기술 스택 변경 시 상위 레이어의 코드 수정을 최소화할 수 있다.

## 3. 요약

스토리지 모듈의 물리적 분리는 **인프라스트럭처의 재사용성**과 **계층 간의 엄격한 분리(Layered Architecture)**를 최우선 가치로 둔다. 이는 단일 서비스보다는 다수의 애플리케이션이 동일한 데이터베이스를 공유하거나, 기술적인 계층 분리가 도메인 응집도보다 중요시되는 대규모 시스템 환경에서 유효한 전략이다.

### 결정 근거. JPA 추상화에 따른 물리적 분리의 무용성 (Redundancy with JPA) 
- 우리는 데이터 접근 기술로 **JPA(Hibernate)**를 지속적으로 사용할 계획이다. 
- JPA는 이미 그 자체로 강력한 추상화 계층을 제공하므로, 하위 데이터베이스 엔진 교체(예: MySQL ↔ PostgreSQL)는 모듈 분리가 아닌 JPA 설정(Dialect/Driver) 변경으로 해결된다. 
- 스토리지 모듈의 물리적 분리는 데이터 접근 패러다임 자체가 변경(예: JPA → MyBatis/MongoDB)될 때만 기술적 이점을 가지므로, 현재 기술 스택에서는 **불필요한 오버헤드(패키지 가시성 제약, 매핑 비용)**일 뿐이다.
